// Generated by the Tensor Algebra Compiler (tensor-compiler.org)
// taco "A(i,j)=B(i,j)*C(i,j)" -f=A:ss:0,1 -f=B:ss:0,1 -f=C:ss:0,1 -write-source=taco_kernel.c -write-compute=taco_compute.c -write-assembly=taco_assembly.c
#ifndef TACO_C_HEADERS
#define TACO_C_HEADERS
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <stdbool.h>
#include <math.h>
#include <complex.h>
#include <string.h>
#define TACO_MIN(_a,_b) ((_a) < (_b) ? (_a) : (_b))
#define TACO_MAX(_a,_b) ((_a) > (_b) ? (_a) : (_b))
#define TACO_DEREF(_a) (((___context___*)(*__ctx__))->_a)
#ifndef TACO_TENSOR_T_DEFINED
#define TACO_TENSOR_T_DEFINED
typedef enum { taco_mode_dense, taco_mode_sparse } taco_mode_t;
typedef struct {
  int32_t      order;         // tensor order (number of modes)
  int32_t*     dimensions;    // tensor dimensions
  int32_t      csize;         // component size
  int32_t*     mode_ordering; // mode storage ordering
  taco_mode_t* mode_types;    // mode storage types
  uint8_t***   indices;       // tensor index data (per mode)
  uint8_t*     vals;          // tensor values
  int32_t      vals_size;     // values array size
} taco_tensor_t;
#endif
int cmp(const void *a, const void *b) {
  return *((const int*)a) - *((const int*)b);
}
#endif

int compute(taco_tensor_t *A, taco_tensor_t *B, taco_tensor_t *C) {
  double* restrict A_vals = (double*)(A->vals);
  int* restrict B1_pos = (int*)(B->indices[0][0]);
  int* restrict B1_crd = (int*)(B->indices[0][1]);
  int* restrict B2_pos = (int*)(B->indices[1][0]);
  int* restrict B2_crd = (int*)(B->indices[1][1]);
  double* restrict B_vals = (double*)(B->vals);
  int* restrict C1_pos = (int*)(C->indices[0][0]);
  int* restrict C1_crd = (int*)(C->indices[0][1]);
  int* restrict C2_pos = (int*)(C->indices[1][0]);
  int* restrict C2_crd = (int*)(C->indices[1][1]);
  double* restrict C_vals = (double*)(C->vals);

  int32_t pA2 = 0;

  int32_t pB1 = B1_pos[0];
  int32_t pB1_end = B1_pos[1];
  int32_t pC1 = C1_pos[0];
  int32_t pC1_end = C1_pos[1];

  while (pB1 < pB1_end && pC1 < pC1_end) {
    int32_t iB = B1_crd[pB1];
    int32_t iC = C1_crd[pC1];
    int32_t i = TACO_MIN(iB,iC);
    if (iB == i && iC == i) {
      int32_t pB2 = B2_pos[pB1];
      int32_t pB2_end = B2_pos[(pB1 + 1)];
      int32_t pC2 = C2_pos[pC1];
      int32_t pC2_end = C2_pos[(pC1 + 1)];

      while (pB2 < pB2_end && pC2 < pC2_end) {
        int32_t jB = B2_crd[pB2];
        int32_t jC = C2_crd[pC2];
        int32_t j = TACO_MIN(jB,jC);
        if (jB == j && jC == j) {
          A_vals[pA2] = B_vals[pB2] * C_vals[pC2];
          pA2++;
        }
        pB2 += (int32_t)(jB == j);
        pC2 += (int32_t)(jC == j);
      }
    }
    pB1 += (int32_t)(iB == i);
    pC1 += (int32_t)(iC == i);
  }
  return 0;
}

int assemble(taco_tensor_t *A, taco_tensor_t *B, taco_tensor_t *C) {
  int* restrict A1_pos = (int*)(A->indices[0][0]);
  int* restrict A1_crd = (int*)(A->indices[0][1]);
  int* restrict A2_pos = (int*)(A->indices[1][0]);
  int* restrict A2_crd = (int*)(A->indices[1][1]);
  double* restrict A_vals = (double*)(A->vals);
  int* restrict B1_pos = (int*)(B->indices[0][0]);
  int* restrict B1_crd = (int*)(B->indices[0][1]);
  int* restrict B2_pos = (int*)(B->indices[1][0]);
  int* restrict B2_crd = (int*)(B->indices[1][1]);
  int* restrict C1_pos = (int*)(C->indices[0][0]);
  int* restrict C1_crd = (int*)(C->indices[0][1]);
  int* restrict C2_pos = (int*)(C->indices[1][0]);
  int* restrict C2_crd = (int*)(C->indices[1][1]);

  A1_pos = (int32_t*)malloc(sizeof(int32_t) * 2);
  A1_pos[0] = 0;
  int32_t A1_crd_size = 1048576;
  A1_crd = (int32_t*)malloc(sizeof(int32_t) * A1_crd_size);
  int32_t pA1 = 0;
  int32_t A2_pos_size = 1048576;
  A2_pos = (int32_t*)malloc(sizeof(int32_t) * A2_pos_size);
  A2_pos[0] = 0;
  int32_t A2_crd_size = 1048576;
  A2_crd = (int32_t*)malloc(sizeof(int32_t) * A2_crd_size);
  int32_t pA2 = 0;


  int32_t pB1 = B1_pos[0];
  int32_t pB1_end = B1_pos[1];
  int32_t pC1 = C1_pos[0];
  int32_t pC1_end = C1_pos[1];

  while (pB1 < pB1_end && pC1 < pC1_end) {
    int32_t iB = B1_crd[pB1];
    int32_t iC = C1_crd[pC1];
    int32_t i = TACO_MIN(iB,iC);
    if (iB == i && iC == i) {
      int32_t pA2_begin = pA2;
      if (A2_pos_size <= pA1 + 1) {
        A2_pos = (int32_t*)realloc(A2_pos, sizeof(int32_t) * A2_pos_size * 2);
        A2_pos_size *= 2;
      }

      int32_t pB2 = B2_pos[pB1];
      int32_t pB2_end = B2_pos[(pB1 + 1)];
      int32_t pC2 = C2_pos[pC1];
      int32_t pC2_end = C2_pos[(pC1 + 1)];

      while (pB2 < pB2_end && pC2 < pC2_end) {
        int32_t jB = B2_crd[pB2];
        int32_t jC = C2_crd[pC2];
        int32_t j = TACO_MIN(jB,jC);
        if (jB == j && jC == j) {
          if (A2_crd_size <= pA2) {
            A2_crd = (int32_t*)realloc(A2_crd, sizeof(int32_t) * A2_crd_size * 2);
            A2_crd_size *= 2;
          }
          A2_crd[pA2] = j;
          pA2++;
        }
        pB2 += (int32_t)(jB == j);
        pC2 += (int32_t)(jC == j);
      }

      A2_pos[pA1 + 1] = pA2;
      if (pA2_begin < pA2) {
        if (A1_crd_size <= pA1) {
          A1_crd = (int32_t*)realloc(A1_crd, sizeof(int32_t) * A1_crd_size * 2);
          A1_crd_size *= 2;
        }
        A1_crd[pA1] = i;
        pA1++;
      }
    }
    pB1 += (int32_t)(iB == i);
    pC1 += (int32_t)(iC == i);
  }

  A1_pos[1] = pA1;

  A_vals = (double*)malloc(sizeof(double) * pA2);

  A->indices[0][0] = (uint8_t*)(A1_pos);
  A->indices[0][1] = (uint8_t*)(A1_crd);
  A->indices[1][0] = (uint8_t*)(A2_pos);
  A->indices[1][1] = (uint8_t*)(A2_crd);
  A->vals = (uint8_t*)A_vals;
  return 0;
}

int evaluate(taco_tensor_t *A, taco_tensor_t *B, taco_tensor_t *C) {
  int* restrict A1_pos = (int*)(A->indices[0][0]);
  int* restrict A1_crd = (int*)(A->indices[0][1]);
  int* restrict A2_pos = (int*)(A->indices[1][0]);
  int* restrict A2_crd = (int*)(A->indices[1][1]);
  double* restrict A_vals = (double*)(A->vals);
  int* restrict B1_pos = (int*)(B->indices[0][0]);
  int* restrict B1_crd = (int*)(B->indices[0][1]);
  int* restrict B2_pos = (int*)(B->indices[1][0]);
  int* restrict B2_crd = (int*)(B->indices[1][1]);
  double* restrict B_vals = (double*)(B->vals);
  int* restrict C1_pos = (int*)(C->indices[0][0]);
  int* restrict C1_crd = (int*)(C->indices[0][1]);
  int* restrict C2_pos = (int*)(C->indices[1][0]);
  int* restrict C2_crd = (int*)(C->indices[1][1]);
  double* restrict C_vals = (double*)(C->vals);

  A1_pos = (int32_t*)malloc(sizeof(int32_t) * 2);
  A1_pos[0] = 0;
  int32_t A1_crd_size = 1048576;
  A1_crd = (int32_t*)malloc(sizeof(int32_t) * A1_crd_size);
  int32_t pA1 = 0;
  int32_t A2_pos_size = 1048576;
  A2_pos = (int32_t*)malloc(sizeof(int32_t) * A2_pos_size);
  A2_pos[0] = 0;
  int32_t A2_crd_size = 1048576;
  A2_crd = (int32_t*)malloc(sizeof(int32_t) * A2_crd_size);
  int32_t pA2 = 0;
  int32_t A_capacity = 1048576;
  A_vals = (double*)malloc(sizeof(double) * A_capacity);


  int32_t pB1 = B1_pos[0];
  int32_t pB1_end = B1_pos[1];
  int32_t pC1 = C1_pos[0];
  int32_t pC1_end = C1_pos[1];

  while (pB1 < pB1_end && pC1 < pC1_end) {
    int32_t iB = B1_crd[pB1];
    int32_t iC = C1_crd[pC1];
    int32_t i = TACO_MIN(iB,iC);
    if (iB == i && iC == i) {
      int32_t pA2_begin = pA2;
      if (A2_pos_size <= pA1 + 1) {
        A2_pos = (int32_t*)realloc(A2_pos, sizeof(int32_t) * A2_pos_size * 2);
        A2_pos_size *= 2;
      }

      int32_t pB2 = B2_pos[pB1];
      int32_t pB2_end = B2_pos[(pB1 + 1)];
      int32_t pC2 = C2_pos[pC1];
      int32_t pC2_end = C2_pos[(pC1 + 1)];

      while (pB2 < pB2_end && pC2 < pC2_end) {
        int32_t jB = B2_crd[pB2];
        int32_t jC = C2_crd[pC2];
        int32_t j = TACO_MIN(jB,jC);
        if (jB == j && jC == j) {
          if (A_capacity <= pA2) {
            A_vals = (double*)realloc(A_vals, sizeof(double) * A_capacity * 2);
            A_capacity *= 2;
          }
          A_vals[pA2] = B_vals[pB2] * C_vals[pC2];
          if (A2_crd_size <= pA2) {
            A2_crd = (int32_t*)realloc(A2_crd, sizeof(int32_t) * A2_crd_size * 2);
            A2_crd_size *= 2;
          }
          A2_crd[pA2] = j;
          pA2++;
        }
        pB2 += (int32_t)(jB == j);
        pC2 += (int32_t)(jC == j);
      }

      A2_pos[pA1 + 1] = pA2;
      if (pA2_begin < pA2) {
        if (A1_crd_size <= pA1) {
          A1_crd = (int32_t*)realloc(A1_crd, sizeof(int32_t) * A1_crd_size * 2);
          A1_crd_size *= 2;
        }
        A1_crd[pA1] = i;
        pA1++;
      }
    }
    pB1 += (int32_t)(iB == i);
    pC1 += (int32_t)(iC == i);
  }

  A1_pos[1] = pA1;

  A->indices[0][0] = (uint8_t*)(A1_pos);
  A->indices[0][1] = (uint8_t*)(A1_crd);
  A->indices[1][0] = (uint8_t*)(A2_pos);
  A->indices[1][1] = (uint8_t*)(A2_crd);
  A->vals = (uint8_t*)A_vals;
  return 0;
}
